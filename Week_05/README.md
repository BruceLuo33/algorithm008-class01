# 第五周学习记录(5.11-5.17)

<span id ="0">
 
## [一、刷题记录](#1)

| [周一](#1.1)  |[周二](#1.2)  | [ 周三](#1.3) |[周四](#1.4) | [周五](#1.5) |[周六](#1.6) | [周日](#1.7) |
| :---: | :----: | :---: | :----: | :----: | :----: | :----: |



 
## [二、数据结构与算法笔记](#2)
  * [1. 动态规划](#2.1)
  * [2. Union-Find](#2.2)
  * [3. ](#2.3)
  * [4. ](#2.4)
  * [5. ](#2.5)
  * [6. ](#2.6)


<h2 id = "1">一、刷题记录</h2>


| 题目类型 | 知识点 | 题目 | 完成情况 | 地址 |
| --- | --- | --- | --- | --- |
|  |  |   |    | [](#) |



<h3 id = "1.1">周一(5.18)</h3>

[返回目录](#0)

休息

<h3 id = "1.2">周二(5.19)</h3>

[返回目录](#0)

#### 复习 [Leetcode 74：搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

5.16 第一遍，5.19 第二遍
思路一：二分查找。一开始的想法很粗暴，先二分找中间行，再二分找中间列，但这样子一来复杂度就很高，而且代码也很难写。看了评论区，找到了一个非常厉害的操作，通过整除和取模运算将一维的坐标转换为二维。
思路二：迭代。从矩阵的右上角或者左下角开始比较。这个优势在于每一个数值，都是当下行的最大（对应右上角）或者最小值（对应左下）,而如果是其他两种方式，其实就是相当于从matrix 最开始和结束的地方进行搜索。
复杂度分析：O（logN）


<h3 id = "1.3">周三(5.20)</h3>

[返回目录](#0)

主题：；技巧：；题数：新题 道，复习 道

#### 复习 [Leetcode 127：单词接龙](https://leetcode-cn.com/problems/word-ladder/)
5.13 第一遍，5.14 第二遍，5.20 第三遍
- 思路：BFS。步骤如下：
1. 将第一个单词节点加入队列，depth 设置为 0，在最后返回的时候 再 +1；
2. 方法是层序遍历，那么关键就在于如何讲每一层顺序放入queue中。在这个题目中，我们采用的是两个 while 循环的形式：
   - 第一个`while(!queue.isEmpty())` 用来判断整个遍历是否完成
   - 第二个`while(size > 0)`用来判断某一层是否完成。这里的 `size = queue.size()`，之所以要用一个新的参数来判定是因为 queue 在第二个while中会发生变化，所以需要一个固定的值来保证不会超出这一层的范围。
   - 例如，刚开始的时候只有一个 beginWord，那么 size 就是 1. 而后在第二个while 中每次都会 size -= 1；所以对于这一层而言，只会循环一次便跳出循环，来到最外层的 while 循环。
3. 在两个while 循环之内，还需要一个 for-loop，这个循环的对象是题目给定的 wordList 数组，也是我们的核心代码部分。需要在这里判断：
   - word 是否已经出现过？如果是，continue；
   - 两个 string 相差是否超过了一个 char 字符？如果是，continue；
   - 是否到达了 endWord？如果是，直接 return depth + 1；
   - 如果都没有，将这个字符标记为出现过，同时将 wordList 中剩下的元素全都加入 queue。此时第二层循环如果结束了，再次进入的时候 size 就变大了。
- 复杂度分析：O（N*26^l），l = len(beginword)

#### 复习 [Leetcode 543：二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)
4.25 第一遍，5.4 第二遍，5.20 第三遍
- 思路：递归。一开始想的是树的直径就是root 往两边走的叶子节点最大深度之和。然而问题在于，叶子节点是对的，但是不一定经过 root。在这里采用递归，可以比较好的避免这个问题：
  - 遍历每一个节点，将这一个节点当作root，求出它的深度，则左子树加右子树的深度，就是当前节点作为 root 的直径；
  - 然后存入 maxDepth，以后的每一个节点都和 maxDepth 比较，如果大于则放入。直到完成循环。
- 注意：递归 return 的项是 leftDepth 和 rightDepth 中较大值 +1，相当于在这里选定了只走较长边。
- 注意：maxDepth 要设置为全局变量，否则只能当作参数输入 depth，会在递归的时候造成麻烦
- 复杂度分析：O（N），空间复杂度：O（k），k为树的深度


<h3 id = "1.4">周四(5.21)</h3>

[返回目录](#0)

主题：；技巧：；题数：新题 道，复习 道


#### 复习 [Leetcode 127：单词接龙](https://leetcode-cn.com/problems/word-ladder/)
5.13 第一遍，5.14 第二遍，5.20 第三遍，5.21 第四遍。
思路见[前节](#1.2)


#### 复习 [最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)
5.13 第一遍，5.21 第二遍
思路：这道题的思路其实和 127 题单词接龙非常一致。这道题要求的是从 start 到 end 经过了几次变化。那么就可以理解为假设每一步仅变化一个基因，变化到目标基因需要几步。整个代码在 127 的思路上稍微改改就行了。
注意：bank 是 String 数组，不好判断是否包含某一个字符串，因此将其转为 set 然后再用 contains() 方法


<h3 id = "1.5">周五(5.22)</h3>

[返回目录](#0)

主题：；技巧：；题数：新题 道，复习 道



#### [Leetcode 429：N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)
5.22 第一遍
思路： BFS。背模板就可以了。
注意：size -= 1 要记得
注意：找 children 的时候，应该是 curNode.children 而不是 root.children

#### 复习 [Leetcode 105：从中序和前序遍历重建二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/)

4.29 第一遍，5.5 第二遍，5.22 第三遍
- 思路：回顾一下，前序遍历指的是 root --> left --> right，中序遍历指的是 left --> root --> right
  - 根据两个遍历的特征，我们可以知道，前序遍历数组的第一个元素，即为根节点，再由这个根节点与中序遍历匹配，找到中序遍历中的根节点，则其左边就是左子树，右边就是右子树。然后再次回到前序遍历数组剩下的部分，第一个元素为右子树的根节点，以此类推。
  - 由上述分析可以看出，递归非常适合这道题目。
- 注意：找 root 节点的时候，下标应该为 p_start 而不是 0
- 注意：helper 函数 return null 的条件应该是 preorder 数组的 start == end
- 注意：helper 函数的输入参数中，p_end 和 i_end 都不用 -1
- 注意：在递归的过程中，p_start 更新应该要 +1. 因为将 preorder 的根节点拿出来后，左子树要从根节点之后开始计算。
- 复杂度分析：O（N），空间复杂度：O（N)

- 优化：在上一个思路中，我们发现每一次从 inorder 数组中去找 root 节点，都需要用 for 循环去遍历，这样就无疑增加了复杂度，
  - 基于此，考虑加入一个 Map 来降低复杂度，将 inorder 的每一个数字和位置都输入 map，可以将复杂度降低很多


#### 复习 [Leetcode 515：在树的每一行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)
 5.13 第一遍，5.22 第二遍
 - 思路：BFS。递归每一层，找到每一层的最大值，将其放入ans 数组即可。
 - 注意：
   1. max 的初始化 `int max = Integer.MIN_VALUE` 要放在第一个 while 循环中
   2. 对 queue 首元素的提取，要放在第二个 while 里面
   3. 继续往 queue 中添加的是 node 的左右子节点
   4. 往queue中添加TreeNode 时，要先判断左右子树是否为空

#### 复习 [Leetcode 200：岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)
5.14 第一遍，5.22 第二遍
- 思路：核心步骤在于先找到第一个值为 1 的点，然后找到所有与之相邻的值为 1 的点，如果找不到了，则将 count + 1，然后继续循环。同时为了避免出现重复循环的问题以及数组越界的问题，我们需要两个措施：
  1. 将已经走过的地方从 1 -> 2，防止多次循环。`grid[i][j] = 2`
  2. 右方和下方都不能超过二维数组的边界。`if (i < 0 || j < 0 || i < grid.length - 1 || j < grid[0].length - 1 || grid[i][j] != '1')`
- 注意：给定的是 char 数组，而不是 int 数组。


#### 复习 [Leetcode 46：全排列](https://leetcode-cn.com/problems/permutations/)
5.8 第一遍，5.22 第二遍
- 思路一：回溯。
- 注意：在result.add(路径)这里，括号内要写 `new LinkedList<Integer>(track)` 而不能简单的写 `track`。否则会出现空链表。
- 复杂度分析：O（N）

#### 复习 [Leetcode 47：全排列II](https://leetcode-cn.com/problems/permutations-ii/)
5.9 第一遍，5.22 第二遍
- 思路：这道题与上一题46很像，不同之处在于这里需要剪枝。在剪枝之前，需要先对数据进行排序。尽管排序也会花一定的时间，但是与回溯算法本身的复杂度相比还是低很多
- 同时要注意，这里给定的序列中就有重复元素，所以最终的排列结果，会出现[1,1,2] 和 [1,1,2]，需要去除其中的一个。
  1. 在主函数中，将 nums[] 排序
  2. 和 46 题相比，多用一个 used[] 的boolean 数组来记录某一个元素是否已经在前面出现过。具体方法为：在 `track.add(nums[i])` 之后，将 `used[i] = true`；同时，在回退状态之后，将 `used[i] = false`
  3. 核心的步骤，在于对重复元素的判断。在上一题中，我们使用的是 `if (track.contains(nums[i])) continue`，但是在这里行不通，原因是在给定的数组中就已经有了重复元素。这条语句的适用条件为 [1,2,3] 这样的数组，但是题目给出的是 [1,1,2] 等类似的数组。如果用这条语句来判断是否跳过，则会出现错误。
  4. 基于第三点，和之前设置的 used 数组，我们可以用这条语句来判定：`if (used[i] || i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;`，它表示了两种情况：第一，used[i] 已经用过了，那么肯定要跳过；第二，used[i-1] 都没用过，但是nums[i] == nums[i-1]，这相当于在判断used[i] 之前，就已经判断了元素是否重复。因为我们事先排序了，所以这个判断才能实现。

#### 复习 [Leetcode 77：组合](https://leetcode-cn.com/problems/combinations/)
5.9 第一遍，5.22 第二遍
- 思路：回溯算法。和 46 题的思路非常相似，都是需要利用到回溯。
  1. track 要创建为 LinkedList<>() 对象，这样在回退状态的时候可以用 removeLast 方法，如果不创建为这个对象，需要改写成这样：`track.remove(track.size() - 1);`
  2. for 循环的判断，i <= n 而不仅仅是 <。因为 start 是从 1 开始取并且 n 是可以取得到的。

#### 复习 [Leetcode 78：子集](https://leetcode-cn.com/problems/subsets/)
5.9 第一遍，5.22 第二遍
思路：回溯算法。套模板就可以了。
注意：模板中不再需要 if 来判断结束条件，因为这道题求子集，相当于决策树上的每一个节点的路径数组都要访问到。





<h3 id = "1.6">周六(5.16)</h3>

[返回目录](#0)

主题：；技巧：；题数：新题 道，复习 道

#### [Leetcode 35：搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)
5.23 第一遍
思路：二分查找。为了方便思考，可以在最开始的地方列出 target 在nums数组两端的情况。
复杂度分析：O（logN）


#### 复习 [Leetcode 45：跳跃游戏II](https://leetcode-cn.com/problems/jump-game-ii/)
5.15 第一遍，5.23 第二遍
- 思路：贪心算法，和 55 题思路还是比较相似，
  1. 以第一个位置为起跳点，例如 `nums[0] = 3`，说明第一个格子能跳三格，nums[3] 为第二个节点，count = 2；
  2. 然后，找到这三格中的最大数值，代表的即为这三个格子中最远能达到的距离，它即为下一个节点。
  3. 因为最后一个位置代表已经到达目标，所以循环终止条件应该为 `i < nums.length - 1`
-复杂度分析：O（N）


#### 复习 [Leetcode 18：四数之和](https://leetcode-cn.com/problems/4sum/)
4.12 第一遍，5.23 第二遍
- 思路：和三数之和很类似，关键在于剪枝：
  1. 最开始的时候要判断数组元素是否大于四个；
  2. 每一个 for loop 都要判断是否出现了相同的元素，如果是，就continue；
  3. 第一个循环的时候，要判断 `min > target` 和 `max < target` 是否成立，注意如果成立，也不能代表可以直接 return ans，要 continue；
  4. 最内存的 while 循环，当 sum = target 的时候，要注意除了 first 与 last 的移动之外，还需要剪枝，即判断是否有相同元素出现，如果是，则跳过
复杂度分析：O（N^3）

#### 复习 [Leetcode 169：多数元素](https://leetcode-cn.com/problems/majority-element/)
5.7 第一遍，5.23 第二遍
- 思路一：数学方法。因为多数元素表示的是在整个数组中占比超过 1/2，那么将数组排序后 n/2 位置的元素一定就是多数元素
  - 复杂度分析：O（NlogN）
- 思路二：HashMap。将元素都放入 HashMap，并判断个数是否 >= n/2。如果是，则返回该元素
   复杂度分析：O（N）
- 思路三：投票法。我们假设这样一个场景，在一个游戏中，分了若干个队伍，有一个队伍的人数超过了半数。所有人的战力都相同，不同队伍的两个人遇到就是同归于尽，同一个队伍的人遇到则战力值+1。而如果战力值清空为零了，说明这些都不是众数，将下一个遇到的数赋值为 compare 的数，同时将 count 置为 1.
  - 复杂度分析：O（N）


<h3 id = "1.7">周日(5.17)</h3>

[返回目录](#0)

主题：；技巧：；题数：新题 道，复习 道

#### [Leetcode 62：不同路径](https://leetcode-cn.com/problems/unique-paths/)
5.24 第一遍
- 思路：动态规划。将大问题分解为小问题，大问题是到达最终的 finish，思考如何才能完成？很简单，从上方或者左方各自向终点移动一步即可。每一个位置都是这样的过程，一直自底向顶，回到start，说明完成。关键问题在于对初始状态的判断：
  1. 如果 `i == 0 || j == 0`，那么对应的 dp 矩阵的值为1，它表达的意思是，如果在上面和左侧的矩阵的“边”上，那么它只有一种可能达成，即由上一个同行/列的空格往下一直走，直到终点，因此此时的 dp 将不再是上和左两个格子共同构成的了，而是只有一种可能，那就是从起点直到终点一条路径；
  2. 不能设置 `if(m == 0 || n == 0) dp[m][n] = 0`，因为这实际上没有判断上/左边界的情况；
  3. 注意题目求的是到达终点的路径有多少条，而不是需要多少步到达，这也是状态转移方程为 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` 的原因，它表示的是最后终点的可能性路径，与上左两个点的可能性之和是相同的。
- 复杂度分析：O（MxN）

#### [Leetcode 63：不同路径II](https://leetcode-cn.com/problems/unique-paths-ii/)
5.24 第一遍
思路：动态规划。和前一题思路一致。


#### 复习 [Leetcode 47：全排列II](https://leetcode-cn.com/problems/permutations-ii/)
5.9 第一遍，5.22 第二遍，5.24 第三遍
思路见[前节](#1.5)





<h2 id = "2">二、数据结构与算法笔记</h2>


<h3 id = "2.1">1. 动态规划</h3>

[返回目录](#0)




<h3 id = "2.2">2. Union-Find</h3>

[返回目录](#0)



<h3 id = "2.3">3. </h3>

[返回目录](#0)






<h3 id = "2.4">4. </h3>

[返回目录](#0)




<h3 id = "2.5">5. </h3>

[返回目录](#0)


<h3 id = "2.6">6. </h3>

[返回目录](#0)













