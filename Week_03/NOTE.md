# 一、刷题记录
## 周一
主题：二叉树；技巧：递归、中序遍历；题数：
### Leetcode 98：[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)。
4.27 第一遍
1. 思路一：中序遍历。题目的要求是判断二叉树值得大小是否为从小到大排列。因此用中序遍历得 左-->根-->右，就可以比较好的解决这个问题。只要相邻两个元素不满足前项小于后项的关系，就返回false。
   - 注意：在存储树的 val 时，数据结构可以用 stack 或者是 arraylist。
   - 注意：判断左子节点的 value（已经存入 ans）与 root.val 关系的时候，要判断是否 >=，而不仅仅是 >
   - 复杂度分析：O（N），空间复杂度：O（N）

2. 思路二：递归。对于每一个节点，正确的范围应该是小于右子树中的最小值 + 大于左子树中的最大值。
因此，我们可以设置递归，每次都已上一个节点作为左/右的一个边界，如果越界，代表出错。举例如下：
```
              10 (-inf, inf)
               /          \
       5(-inf, 10)      17(10, inf)
        /     \          /       \
  3(-inf, 5)  7(5,10)  13(10, 17)   20(17, inf)
```
   - 从上图，我们可以总结出结论：如果是左子节点，那么应该以父节点为右边界，以父节点的左边界为左边界；如果是右子节点，应该以父节点为左边界，以父节点的右边界为右边界。
   - 注意：设置max/min 的时候，要将其再扩大一个位置，MAX_VALUE + 1 和 MIN+VALUE - 1
   - 复杂度分析：O（N），空间复杂度：O（1）
